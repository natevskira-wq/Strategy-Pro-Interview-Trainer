<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gambit - Interview Strategist</title>
    
    <!-- 1. LIBRARIES -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;1,300&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <!-- 2. SCRIPTS -->
    <script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: { 
                        chessDark: '#262421', 
                        chessLight: '#f0d9b5',
                        accent: '#c5a076',
                    },
                    fontFamily: {
                        serif: ['Merriweather', 'serif'],
                        sans: ['Inter', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        body { background-color: #262421; color: #e2e8f0; overscroll-behavior: none; }
        
        /* Smooth Fade */
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }

        /* Pulse for Recording */
        .record-pulse { animation: pulse 1.5s infinite; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
        }

        /* Drag Handle */
        .drag-handle { touch-action: none; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <div id="app" class="flex flex-col h-full relative">

        <!-- ================= 1. HEADER ================= -->
        <header class="bg-gray-900 border-b border-gray-800 p-3 shrink-0 flex items-center justify-between z-30 h-[60px]">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-chess-knight text-2xl text-accent"></i>
                <div>
                    <h1 class="font-serif font-bold text-sm tracking-wide text-chessLight">GAMBIT</h1>
                    <div class="flex items-center gap-2 text-[10px] text-gray-400">
                        <span><i class="fa-solid fa-trophy text-yellow-500"></i> Elo: {{ calculateElo }}</span>
                    </div>
                </div>
            </div>
            
            <button @click="showSettings = true" class="w-8 h-8 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:text-white">
                <i class="fa-solid fa-gear"></i>
            </button>
        </header>

        <!-- ================= 2. RESIZABLE BOARD SECTION ================= -->
        <div class="relative shrink-0 bg-[#312e2b] border-b border-gray-700 shadow-xl z-20 transition-all duration-75 ease-linear"
             :style="{ height: boardHeight + 'px' }">
            
            <!-- Toggle Button (Hide/Show) -->
            <button @click="toggleBoard" class="absolute top-2 right-2 text-gray-500 hover:text-white z-30 p-2 bg-black/20 rounded-full">
                <i class="fa-solid" :class="boardHeight < 50 ? 'fa-chevron-down' : 'fa-chevron-up'"></i>
            </button>

            <!-- Chess Board Container -->
            <div class="w-full h-full flex items-center justify-center overflow-hidden pb-6 pt-2">
                
                <!-- The Board (Only render if big enough) -->
                <div id="myBoard" 
                     v-show="boardHeight > 50"
                     :style="{ width: (Math.max(0, boardHeight - 40)) + 'px', height: (Math.max(0, boardHeight - 40)) + 'px' }"
                     class="shadow-2xl"></div>
                
                <!-- Hidden State Text -->
                <div v-if="boardHeight <= 50" class="text-xs text-gray-500 font-bold uppercase tracking-widest">
                    Board Collapsed
                </div>
            </div>

            <!-- Drag Handle -->
            <div class="absolute bottom-0 left-0 right-0 h-6 drag-handle flex items-center justify-center border-t border-gray-600 bg-gray-800 hover:bg-gray-700 cursor-row-resize z-40 group"
                 @mousedown="startDrag" 
                 @touchstart="startDrag">
                <div class="flex gap-1">
                    <div class="w-1 h-1 rounded-full bg-gray-500 group-hover:bg-gray-300"></div>
                    <div class="w-1 h-1 rounded-full bg-gray-500 group-hover:bg-gray-300"></div>
                    <div class="w-1 h-1 rounded-full bg-gray-500 group-hover:bg-gray-300"></div>
                </div>
            </div>
        </div>

        <!-- ================= 3. MAIN SCROLL AREA ================= -->
        <main class="flex-1 overflow-y-auto relative bg-[#262421] p-4 pb-32 space-y-6" id="scrollContainer">
            
            <!-- Empty State -->
            <div v-if="cards.length === 0" class="text-center py-12 opacity-50">
                <h2 class="text-xl font-serif text-chessLight">Strategize</h2>
                <p class="text-sm text-gray-400 mt-2">Press 'Play Move' to begin your opening.</p>
            </div>

            <!-- CARDS LIST -->
            <div v-for="(card, index) in cards" :key="card.id" 
                 class="rounded-lg shadow-lg overflow-hidden border transition-all duration-300 relative"
                 :class="card.type === 'q' ? 'bg-gray-100 border-gray-300 text-gray-900' : 'bg-gray-800 border-gray-700 text-gray-100'">

                <!-- Card Header -->
                <div class="px-4 py-2 border-b flex justify-between items-center"
                     :class="card.type === 'q' ? 'border-gray-200 bg-gray-200' : 'border-gray-700 bg-gray-900'">
                    <span class="text-xs font-bold uppercase tracking-wider opacity-70">
                        {{ card.type === 'q' ? 'Opening (Question)' : 'Defense (Answer)' }}
                    </span>
                    
                    <!-- Timer -->
                    <div class="flex items-center gap-2 text-xs font-mono bg-opacity-20 bg-black px-2 py-1 rounded">
                        <input v-if="card.isEditingTime" 
                               type="number" 
                               v-model.number="card.seconds" 
                               @blur="card.isEditingTime = false"
                               class="w-12 bg-transparent text-center border-b border-gray-500 focus:outline-none"
                               ref="timeInput">
                        <span v-else @click="editTimer(index)" class="cursor-pointer hover:underline">
                            {{ formatTime(card.seconds) }}
                        </span>
                        <button @click="toggleTimer(index)">
                            <i :class="card.timerActive ? 'fa-solid fa-pause text-red-500' : 'fa-solid fa-play text-green-500'"></i>
                        </button>
                    </div>
                </div>

                <!-- Card Body -->
                <div class="p-4 relative min-h-[100px]">
                    
                    <!-- BLINDFOLD OVERLAY (Only for Answers) -->
                    <div v-if="isBlindfold && card.type === 'a' && !card.revealed" 
                         class="absolute inset-0 z-10 bg-gray-900 flex flex-col items-center justify-center cursor-pointer"
                         @click="card.revealed = true">
                        <i class="fa-solid fa-eye-slash text-2xl text-accent mb-2"></i>
                        <span class="text-xs font-bold text-gray-400 uppercase">Hidden (Tap to Reveal)</span>
                    </div>

                    <!-- Text Area (Auto Sizing) -->
                    <textarea v-model="card.text" 
                              placeholder="Type notes..."
                              @input="autoResize($event)"
                              class="w-full bg-transparent resize-none outline-none text-sm font-serif leading-relaxed overflow-hidden block"
                              :class="card.type === 'q' ? 'placeholder-gray-400' : 'placeholder-gray-600'"
                              style="height: 80px;"></textarea>

                    <!-- STT Section (Answers Only) -->
                    <div v-if="card.type === 'a'" class="mt-4 pt-4 border-t border-gray-700">
                        
                        <!-- STT Header -->
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-[10px] uppercase text-gray-500 font-bold">Verbal Transcript</span>
                            
                            <!-- STT Toolbar -->
                            <div class="flex items-center gap-2">
                                <button v-if="card.spokenText" @click="copySpokenToMain(index)" class="text-[10px] bg-blue-600 hover:bg-blue-500 text-white px-2 py-1 rounded uppercase font-bold" title="Promote to Answer">
                                    <i class="fa-solid fa-arrow-up mr-1"></i> Use
                                </button>
                                <button v-if="card.spokenText" @click="copyToClipboard(card.spokenText)" class="text-xs bg-gray-600 hover:bg-gray-500 text-white px-2 py-1 rounded">
                                    <i class="fa-regular fa-copy"></i>
                                </button>
                                <button @click="toggleSTT(index)" 
                                        class="w-8 h-8 rounded-full flex items-center justify-center transition-all shadow-lg text-white"
                                        :class="card.isListening ? 'bg-red-600 record-pulse' : 'bg-gray-600 hover:bg-gray-500'">
                                    <i :class="card.isListening ? 'fa-solid fa-microphone' : 'fa-solid fa-microphone-slash'"></i>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Spoken Text Area -->
                        <div class="bg-black/30 rounded p-3 text-xs italic text-gray-300 min-h-[40px] whitespace-pre-wrap leading-relaxed border border-gray-700/50">
                            {{ card.spokenText || 'Voice notes will appear here...' }}
                        </div>
                    </div>
                </div>

                <!-- Footer (Delete Button) -->
                <div class="bg-black/10 px-4 py-2 flex justify-between items-center border-t border-black/5">
                    <div class="text-[10px] text-gray-500 font-mono">
                        {{ card.similarity > 0 ? card.similarity + '% Match' : '' }}
                    </div>
                    <button @click="deleteCard(index)" class="text-xs text-red-400 hover:text-red-200 flex items-center gap-1 opacity-60 hover:opacity-100 transition-opacity">
                        <i class="fa-solid fa-trash"></i> Delete
                    </button>
                </div>

            </div>
        </main>

        <!-- ================= 4. FOOTER CONTROLS ================= -->
        <footer class="bg-gray-900 border-t border-gray-800 p-4 shrink-0 z-30 pb-safe">
            <div class="grid grid-cols-4 gap-3 max-w-md mx-auto">
                <button @click="toggleAutoPlay" 
                        class="col-span-1 flex flex-col items-center justify-center rounded-lg transition-colors py-2"
                        :class="autoPlayActive ? 'bg-red-900/30 text-red-500' : 'text-gray-500'">
                    <i :class="autoPlayActive ? 'fa-solid fa-stop' : 'fa-solid fa-robot'" class="text-xl mb-1"></i>
                    <span class="text-[9px] uppercase font-bold">Auto</span>
                </button>

                <button @click="addCard" 
                        class="col-span-2 bg-accent hover:bg-[#b08d65] text-gray-900 rounded-xl shadow-lg shadow-yellow-900/20 flex flex-col items-center justify-center active:scale-95 transition-transform">
                    <span class="text-lg font-bold font-serif">Play Move</span>
                    <span class="text-[10px] uppercase tracking-widest opacity-70">
                        {{ turn === 'w' ? 'Question' : 'Answer' }}
                    </span>
                </button>

                <button @click="isBlindfold = !isBlindfold" 
                        class="col-span-1 flex flex-col items-center justify-center rounded-lg transition-colors py-2"
                        :class="isBlindfold ? 'bg-blue-900/30 text-blue-400' : 'text-gray-500'">
                    <i :class="isBlindfold ? 'fa-solid fa-eye-slash' : 'fa-solid fa-eye'" class="text-xl mb-1"></i>
                    <span class="text-[9px] uppercase font-bold">Blind</span>
                </button>
            </div>
        </footer>

        <!-- ================= 5. SETTINGS ================= -->
        <div v-if="showSettings" class="absolute inset-0 bg-black/80 z-50 flex items-center justify-center p-4 backdrop-blur-sm">
            <div class="bg-gray-800 border border-gray-700 rounded-xl w-full max-w-sm overflow-hidden shadow-2xl p-4 space-y-4">
                <h3 class="font-serif font-bold text-chessLight">Settings</h3>
                
                <div>
                    <label class="text-xs font-bold text-gray-500 uppercase block mb-2">STT Language</label>
                    <select v-model="selectedLang" class="w-full bg-gray-900 border border-gray-600 text-gray-200 rounded p-2 text-sm">
                        <option value="en-US">ðŸ‡ºðŸ‡¸ English</option>
                        <option value="de-DE">ðŸ‡©ðŸ‡ª German</option>
                        <option value="fr-FR">ðŸ‡«ðŸ‡· French</option>
                        <option value="es-ES">ðŸ‡ªðŸ‡¸ Spanish</option>
                    </select>
                </div>

                <div class="grid grid-cols-2 gap-3">
                    <button @click="saveData" class="py-3 bg-gray-700 rounded text-xs font-bold uppercase"><i class="fa-solid fa-download mr-1"></i> Save</button>
                    <button @click="triggerLoad" class="py-3 bg-gray-700 rounded text-xs font-bold uppercase"><i class="fa-solid fa-upload mr-1"></i> Load</button>
                    <input type="file" id="jsonLoad" class="hidden" accept=".json" @change="loadData">
                </div>

                <button @click="resetAll" class="w-full py-3 border border-red-900/50 text-red-500 rounded text-xs font-bold uppercase">Reset Campaign</button>
                <button @click="showSettings = false" class="w-full py-3 bg-gray-900 text-white rounded text-sm">Close</button>
            </div>
        </div>

    </div>

    <script>
        const { createApp, ref, computed, onMounted, nextTick, watch } = Vue;
        
        // Morphy's Opera Game
        const PGN_SEQUENCE = `1. e4 e5 2. Nf3 d6 3. d4 Bg4 4. dxe5 Bxf3 5. Qxf3 dxe5 6. Bc4 Nf6 7. Qb3 Qe7 8. Nc3 c6 9. Bg5 b5 10. Nxb5 cxb5 11. Bxb5+ Nbd7 12. O-O-O Rd8 13. Rxd7 Rxd7 14. Rd1 Qe6 15. Bxd7+ Nxd7 16. Qb8+ Nxb8 17. Rd8#`;

        createApp({
            setup() {
                // State
                const cards = ref([]);
                const showSettings = ref(false);
                const isBlindfold = ref(false);
                const autoPlayActive = ref(false);
                const selectedLang = ref('en-US');
                const turn = ref('w');
                
                // Resizing State
                const boardHeight = ref(250); 
                const lastHeight = ref(250);

                // Logic
                const game = new Chess();
                let board = null;
                let moveQueue = [];
                let currentMoveIndex = 0;
                let timerIntervals = {};
                let autoPlayInterval = null;
                let recognition = null;

                onMounted(() => {
                    initChess();
                    loadLocalData();
                    initSTT();
                });

                watch(cards, () => saveLocalData(), { deep: true });
                watch(selectedLang, () => { if(recognition) recognition.lang = selectedLang.value; });

                // --- 1. RESIZABLE BOARD ---
                function startDrag(e) {
                    e.preventDefault(); 
                    window.addEventListener('mousemove', onDrag);
                    window.addEventListener('mouseup', stopDrag);
                    window.addEventListener('touchmove', onDrag);
                    window.addEventListener('touchend', stopDrag);
                }

                function onDrag(e) {
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const headerOffset = 60; // Approximate header height
                    let newHeight = clientY - headerOffset;
                    
                    if (newHeight < 0) newHeight = 0;
                    if (newHeight > 500) newHeight = 500;
                    
                    boardHeight.value = newHeight;
                    if(board && newHeight > 50) board.resize();
                }

                function stopDrag() {
                    window.removeEventListener('mousemove', onDrag);
                    window.removeEventListener('mouseup', stopDrag);
                    window.removeEventListener('touchmove', onDrag);
                    window.removeEventListener('touchend', stopDrag);
                    
                    // Snap to minimize if too small
                    if(boardHeight.value < 50) boardHeight.value = 30;
                    if(board && boardHeight.value > 50) board.resize();
                }

                function toggleBoard() {
                    if (boardHeight.value > 50) {
                        lastHeight.value = boardHeight.value;
                        boardHeight.value = 30;
                    } else {
                        boardHeight.value = lastHeight.value > 50 ? lastHeight.value : 250;
                        setTimeout(() => { if(board) board.resize(); }, 50);
                    }
                }

                // --- 2. CORE LOGIC ---
                function initChess() {
                    game.load_pgn(PGN_SEQUENCE);
                    moveQueue = game.history({ verbose: true });
                    game.reset();
                    
                    board = Chessboard('myBoard', {
                        position: 'start',
                        draggable: false,
                        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
                    });
                    
                    window.addEventListener('resize', () => { if(board) board.resize(); });
                }

                function addCard() {
                    if (currentMoveIndex < moveQueue.length) {
                        game.move(moveQueue[currentMoveIndex]);
                        if(boardHeight.value > 50) board.position(game.fen());
                        currentMoveIndex++;
                    }
                    
                    turn.value = game.turn();
                    const isWhite = (currentMoveIndex % 2 !== 0); // White moved if index is odd now

                    cards.value.push({
                        id: Date.now(),
                        type: isWhite ? 'q' : 'a',
                        text: '',
                        spokenText: '',
                        similarity: 0,
                        seconds: 0,
                        timerActive: false,
                        isEditingTime: false,
                        isListening: false,
                        revealed: false
                    });

                    nextTick(() => {
                        const el = document.getElementById('scrollContainer');
                        el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
                    });
                }

                function autoResize(event) {
                    const el = event.target;
                    el.style.height = 'auto'; 
                    el.style.height = el.scrollHeight + 'px';
                }

                function deleteCard(index) {
                    if(confirm("Delete this strategic line?")) cards.value.splice(index, 1);
                }

                // --- 3. STT LOGIC ---
                function initSTT() {
                    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                        recognition = new SpeechRecognition();
                        recognition.continuous = true;
                        recognition.interimResults = true;
                        recognition.lang = selectedLang.value;
                    }
                }

                function toggleSTT(index) {
                    if (!recognition) return alert("Browser does not support Speech API");
                    
                    const card = cards.value[index];

                    if (card.isListening) {
                        recognition.stop();
                        card.isListening = false;
                    } else {
                        cards.value.forEach(c => c.isListening = false); // Stop others
                        card.isListening = true;
                        recognition.lang = selectedLang.value;

                        // Memory Logic: Keep old text, add new
                        let sessionPrefix = card.spokenText ? card.spokenText + ' ' : '';
                        let currentSession = '';

                        recognition.start();

                        recognition.onresult = (e) => {
                            let interim = '';
                            let finalChunk = '';

                            for (let i = e.resultIndex; i < e.results.length; ++i) {
                                if (e.results[i].isFinal) finalChunk += e.results[i][0].transcript;
                                else interim += e.results[i][0].transcript;
                            }
                            
                            if(finalChunk) currentSession += finalChunk;
                            
                            // Display: Existing + Current Final + Interim
                            card.spokenText = (sessionPrefix + currentSession + interim).trim();
                            calculateSimilarity(card);
                        };

                        recognition.onend = () => {
                            // Loop to keep alive unless manually stopped
                            if (card.isListening) {
                                sessionPrefix = card.spokenText + ' ';
                                currentSession = '';
                                recognition.start();
                            }
                        };
                    }
                }

                function copySpokenToMain(index) {
                    const card = cards.value[index];
                    card.text = card.spokenText;
                    // Trigger resize logic manually
                    nextTick(() => {
                         const txt = document.querySelectorAll('textarea');
                         txt.forEach(t => { t.style.height = 'auto'; t.style.height = t.scrollHeight + 'px'; });
                    });
                    calculateSimilarity(card);
                }

                function copyToClipboard(text) {
                    navigator.clipboard.writeText(text).then(() => alert("Copied to clipboard"));
                }

                function calculateSimilarity(card) {
                    if(!card.text || !card.spokenText) return;
                    const normalize = (s) => s.toLowerCase().replace(/[^\p{L}\s]/gu, '').split(/\s+/);
                    const s1 = new Set(normalize(card.text));
                    const s2 = new Set(normalize(card.spokenText));
                    const intersect = new Set([...s1].filter(x => s2.has(x)));
                    const union = new Set([...s1, ...s2]);
                    card.similarity = Math.round((intersect.size / union.size) * 100);
                }

                // --- 4. UTILS ---
                function toggleTimer(index) {
                    const card = cards.value[index];
                    if (card.timerActive) { clearInterval(timerIntervals[card.id]); card.timerActive = false; }
                    else { card.timerActive = true; timerIntervals[card.id] = setInterval(() => card.seconds++, 1000); }
                }
                function formatTime(s) { return `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`; }
                function editTimer(index) { cards.value[index].isEditingTime = true; nextTick(()=>document.querySelectorAll('input[type="number"]')[0]?.focus()); }
                
                function toggleAutoPlay() {
                    autoPlayActive.value = !autoPlayActive.value;
                    if(autoPlayActive.value) { addCard(); autoPlayInterval = setInterval(addCard, 4000); }
                    else clearInterval(autoPlayInterval);
                }

                const calculateElo = computed(() => 800 + (cards.value.length*10) + Math.floor(cards.value.reduce((a,c)=>a+(c.similarity||0),0)/5));

                // --- 5. STORAGE ---
                function saveLocalData() { localStorage.setItem('gambitDataV31', JSON.stringify({cards:cards.value, fen:game.fen(), idx:currentMoveIndex})); }
                function loadLocalData() {
                    const d = JSON.parse(localStorage.getItem('gambitDataV31'));
                    if(d) { cards.value=d.cards; game.load(d.fen); if(board) board.position(d.fen); currentMoveIndex=d.idx; cards.value.forEach(c=>c.timerActive=false); }
                }
                function saveData() { 
                    const blob = new Blob([JSON.stringify(cards.value)], {type:'application/json'});
                    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='gambit_campaign.json'; a.click(); 
                }
                function triggerLoad() { document.getElementById('jsonLoad').click(); }
                function loadData(e) { const r=new FileReader(); r.onload=ev=>{ cards.value=JSON.parse(ev.target.result); showSettings.value=false; }; r.readAsText(e.target.files[0]); }
                function resetAll() { if(confirm("Reset Campaign?")) { cards.value=[]; game.reset(); currentMoveIndex=0; if(board) board.start(); localStorage.removeItem('gambitDataV31'); showSettings.value=false; } }

                return {
                    cards, showSettings, isBlindfold, autoPlayActive, selectedLang, turn, boardHeight,
                    startDrag, toggleBoard, autoResize,
                    addCard, deleteCard, toggleTimer, editTimer, formatTime, 
                    toggleSTT, copySpokenToMain, copyToClipboard, calculateElo, toggleAutoPlay,
                    resetAll, saveData, loadData, triggerLoad
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
